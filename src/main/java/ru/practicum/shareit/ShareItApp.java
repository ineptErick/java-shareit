package ru.practicum.shareit;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ShareItApp {
    public static void main(String[] args) {
        SpringApplication.run(ShareItApp.class, args);
    }

    // 15 СПРИНТ

    // 1. Пользователь создаёт такой запрос, когда не может найти нужную вещь,
    //воспользовавшись поиском, но при этом надеется, что у кого-то она всё же
    //имеется. Другие пользователи могут просматривать подобные запросы и, если у
    //них есть описанная вещь и они готовы предоставить её в аренду, добавлять
    //нужную вещь в ответ на запрос.

    // нужно добавить четыре новых эндпоинта:
    //POST /requests — добавить новый запрос вещи. Основная часть запроса —
    //текст запроса, где пользователь описывает, какая именно вещь ему нужна.
    //GET /requests — получить список своих запросов вместе с данными об
    //ответах на них. Для каждого запроса должны указываться описание, дата и
    //время создания и список ответов в формате: id вещи, название, id
    //владельца. Так в дальнейшем, используя указанные id вещей, можно будет
    //получить подробную информацию о каждой вещи. Запросы должны
    //возвращаться в отсортированном порядке от более новых к более старым.
    //GET /requests/all?from={from}&size={size} — получить список запросов,
    //созданных другими пользователями. С помощью этого эндпоинта
    //пользователи смогут просматривать существующие запросы, на которые они
    //могли бы ответить. Запросы сортируются по дате создания: от более новых к
    //более старым. Результаты должны возвращаться постранично. Для этого
    //нужно передать два параметра: from — индекс первого элемента, начиная с
    //0, и size — количество элементов для отображения.
    //GET /requests/{requestId} — получить данные об одном конкретном запросе
    //вместе с данными об ответах на него в том же формате, что и в эндпоинте
    //GET /requests . Посмотреть данные об отдельном запросе может любой
    //пользователь.

    //2. Добавим ещё одну полезную опцию в ваше приложение, чтобы пользователи
    //могли отвечать на запросы друг друга. Для этого при создании вещи должна быть
    //возможность указать id запроса, в ответ на который создаётся нужная вещь.
    //Добавьте поле requestId в тело запроса POST /items . Обратите внимание, что
    //должна сохраниться возможность добавить вещь и без указания requestId .

    // 3. Пользователи уже жалуются, что запросы возвращают слишком много данных и с
    //ними невозможно работать. Эта проблема возникает при просмотре бронирований
    //и особенно при просмотре вещей. Поэтому, чтобы приложение было комфортным
    //для пользователей, а также быстро работало, вам предстоит добавить пагинацию
    //в эндпоинты GET /items , GET /items/search , GET /bookings и GET /bookings/owner .
    //Параметры будут такими же, как и для эндпоинта на получение запросов вещей:
    //номер первой записи и желаемое количество элементов для отображения.

    // 4. тесты
    // Реализовать юнит-тесты для всего кода, содержащего логику. Выберите те
    //классы, которые содержат в себе нетривиальные методы, условия и
    //ветвления. В основном это будут классы сервисов. Напишите юнит-тесты на
    //все такие методы, используя моки при необходимости.
    //Реализовать интеграционные тесты, проверяющие взаимодействие с базой
    //данных. Как вы помните, интеграционные тесты представляют собой более
    //высокий уровень тестирования: их обычно требуется меньше, но покрытие
    //каждого — больше. Мы предлагаем вам создать по одному интеграционному
    //тесту для каждого крупного метода в ваших сервисах. Например, для метода
    //getUserItems в классе ItemServiceImpl .
    //Реализовать тесты для REST-эндпоинтов вашего приложения с
    //использованием MockMVC . Вам нужно покрыть тестами все существующие
    //эндпоинты. При этом для слоя сервисов используйте моки.
    //Реализовать тесты для слоя репозиториев вашего приложения с
    //использованием аннотации @DataJpaTest . Есть смысл написать тесты для тех
    //репозиториев, которые содержат . Работа с аннотацией
    //@DataJpaTest не рассматривалась подробно в уроке, поэтому вам предстоит
    //изучить пример самостоятельно, перейдя по ссылке. Ещё больше деталей вы
    //сможете найти в приложенном файле с советами ментора.
    //кастомные запросы
    //Реализовать тесты для работы с JSON для DTO в вашем приложении с
    //помощью аннотации @JsonTest . Такие тесты имеют смысл в тех случаях,
    // когда ваши DTO содержат в себе некоторую логику. Например, описание
    //формата дат или валидацию. Выберите DTO, где есть , и
    //напишите тесты.
}